% write_fade_hpp.m
% writes out the fader random variable constants to a Verilog header file.
% Values are scaled to work with fixed point math, phase -Pi/Pi corresponds to the twos complement integer range.

function [retval] = write_verilog (states, fd, filename)

    B_phi = 14; % bits in phi word.
    A_phi = 2^(B_phi-1);
    B_cos = 18; % bits in wd_cos_alpha word.
    A_cos = 2^(B_cos-2);

    N = size(states.theta, 1);
    M = size(states.Phi, 3);
    
    fp = fopen(filename, 'w');
    fprintf(fp, '// %s\n', filename);
    fprintf(fp, '// This file autogenerated to provide the "states" structure for the Verilog fader.\n\n');   

    fprintf(fp, 'package states_pack;\n\n');
    fprintf(fp, '    typedef struct {\n');
    fprintf(fp, '        logic signed [%d-1:0]   phi_real     [%d-1:0];\n', B_phi, M);
    fprintf(fp, '        logic signed [%d-1:0]   phi_imag     [%d-1:0];\n', B_phi, M);
    fprintf(fp, '        logic signed [%d-1:0]   wd_cos_alpha [%d-1:0];\n', B_cos, M);
    fprintf(fp, '        logic signed [%d-1:0]   wd_sin_alpha [%d-1:0];\n', B_cos, M);
    fprintf(fp, '    } fade_struct; \n\n');
    
    fprintf(fp, '    const fade_struct state[%d] = {\n', N);
    
    wd_cos_alpha = zeros(1,M);
    wd_sin_alpha = zeros(1,M);

    for i=1:N
        fprintf(fp, '        // channel = %d\n', i-1);
        fprintf(fp, "        \'{\n");
        fprintf(fp, "            \'{");
        for j=1:M
            fprintf(fp, '%d',   round(A_phi*states.Phi(i,1,j)/pi)   );
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // phi_real\n');
            end
        end
        
        fprintf(fp, "            \'{");
        for j=1:M
            fprintf(fp, '%d',   round(A_phi*states.phi(i,1,j)/pi)   );
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // phi_imag\n');
            end
        end
    
        % we need to precompute the Wd*cos(alpha) and Wd*sin(alpha).
        for j=1:M
            alpha = ( 2*pi*j - pi + states.theta(i,1,1) )/(4*M);
            wd_cos_alpha(j) = 2*pi*cos(alpha);
            wd_sin_alpha(j) = 2*pi*sin(alpha);
        end
        
        fprintf(fp, "            \'{");
        for j=1:M
            fprintf(fp, '%d', round(A_cos*wd_cos_alpha(j)/pi)  );
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // wd_cos_alpha\n');
            end
        end
        
        fprintf(fp, "            \'{");
        for j=1:M
            fprintf(fp, '%d', round(A_cos*wd_sin_alpha(j)/pi)  );
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '} // wd_sin_alpha\n');
            end
        end
        
        if (i!=N)
            fprintf(fp, '        },\n');
        else
            fprintf(fp, '        }\n');
        end
    end
    
    fprintf(fp, '    };\n\n');
    fprintf(fp, 'endpackage\n\n');
    
    fclose(fp);

endfunction


