% write_fade_hpp.m
% writes out the fader random variables to a C++ header file for HLS.

function [retval] = write_fader_hpp (states, filename)

    N = size(states.theta, 1);
    M = size(states.Phi, 3);
    
    fp = fopen(filename, 'w');
    fprintf(fp, '// %s\n', filename);
    fprintf(fp, '// This file autogenerated to provide the "states" structure for the HLS C++ fader.\n\n');   
    
    fprintf(fp, 'const rand_state state[%d] = {\n', N);
    
    cos_alpha = zeros(1,M);
    sin_alpha = zeros(1,M);
    for i=1:N
        fprintf(fp, '    // channel = %d\n', i-1);
        fprintf(fp, '    {\n');
        fprintf(fp, '        {');
        for j=1:M
            fprintf(fp, '%f', states.Phi(i,1,j));
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // phi_real\n');
            end
        end
        
        fprintf(fp, '        {');
        for j=1:M
            fprintf(fp, '%f', states.phi(i,1,j));
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // phi_imag\n');
            end
        end
    
        % we need to precompute the cos(alpha) and sin(alpha).
        for j=1:M
            alpha = ( 2*pi*j - pi + states.theta(i,1,1) )/(4*M);
            cos_alpha(j) = cos(alpha);
            sin_alpha(j) = sin(alpha);
        end
        
        fprintf(fp, '        {');
        for j=1:M
            fprintf(fp, '%f', cos_alpha(j));
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '}, // cos_alpha\n');
            end
        end
        
        fprintf(fp, '        {');
        for j=1:M
            fprintf(fp, '%f', sin_alpha(j));
            if (j!=M) 
                fprintf(fp, ', ');
            else
                fprintf(fp, '} // sin_alpha\n');
            end
        end
        
        if (i!=N)
            fprintf(fp, '    },\n');
        else
            fprintf(fp, '    }\n');
        end
    end
    
    fprintf(fp, '};\n');
    
    
    fclose(fp);

endfunction

%        for(int i=0; i<M; i++){
%            theta = 2.0*M_PI*(((double)rand())/rand_max) - M_PI; // uniformly random over [-M_PI, M_PI).
%            alpha = (2.0*M_PI*(i+1) - M_PI + theta)/(4.0*M);
%            std::cout << j << ", " << i << " alpha = " << alpha << ", theta = " << theta << "\n";
%            state[j].cos_alpha[i]    = (fade_type)cos(alpha); // [-1.0, +1.0]
%            state[j].sin_alpha[i]    = (fade_type)sin(alpha);



%typedef struct {
%    fade_type phi_real[M];
%    fade_type phi_imag[M];
%    fade_type cos_alpha[M];
%    fade_type sin_alpha[M];
%} rand_state;

